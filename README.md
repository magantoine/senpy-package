<img alt="SenPy" src="./assets/banner.png"> 

## What is it?

*Notify Me SenPy* is a tool that let's you track your Python scripts' execution and receive a notification whenever the execution reaches certain points.

It is composed of a Python package and a mobile app. The package is used in your Python script to specify which job you want to track and at which points you want to receive notifications. The application is where you can check on your job progress and see the notification history.

<p float="center">
<img src="./assets/jobs.png" alt="job screen" />
</p>

## Usage

You can send notifications from a script to your app using `notify_me`
```python
from senpy import notify_me

notify_me("Great job!")
```

You can track your jobs using the `ntm` python `with statement`:

```python
from senpy import ntm
from time import sleep 

with ntm(range(10)) as iterator:
    for i, item in enumerate(iterator):
        sleep(5)
``` 

## Installation
### 1. Package
First install the *Notify Me SenPy* Python package
```bash
pip install notify-me-senpy
```

Create an account from the command line
```bash
senpy register
>>> ? Username: your_username
>>> ? Password: *********
>>> ? Password confirmation: *********
```

The existing commands are
```bash
senpy {register|login|logout|change_password|delete_account}
```
You are done with the package setup! ðŸŽ‰

### 2. App

Download the *Notify Me SenPy* app from the store.

Once the app installed, open the app and wait until the configuration is done. You should receive a notification confirming that the configuration has been successfully completed. Otherwise, check your connection, try again or try re-installing the app.

Once done, you simply have to log into your account in the app to complete the installation.
<p float="center">
<img src="./assets/login.png" alt="login screen"/>
</p>


## To contribute

### Architecture 

The directory ```senpy_package``` is, at this time, built as follows :
```bash
â”œâ”€â”€â”€senpy # Folder containing the source code
    â”œâ”€â”€â”€account_manager.py # authentication system
    â”œâ”€â”€â”€cli.py # cli utility functions
    â”œâ”€â”€â”€jobs.py # ntm with statement source code
    â”œâ”€â”€â”€notifications.py # notify_me source code
    â”œâ”€â”€â”€request_utils.py # HTTP methods
    â””â”€â”€â”€user_token.py # Auth-token-related functions
â”œâ”€â”€â”€tests # Unittests for each function
    â”œâ”€â”€â”€notify_me.py 
    â””â”€â”€â”€ntm.py
â””â”€â”€â”€setup.py # Package configuration file
```


### Development

To get started, you can create a virtual environnement and install the packages listed in `requirements.txt`:
```
git clone https://github.com/magantoine/senpy-package
pip install virtualenv
virtualenv venv
source venv/bin/activate
cd senpy-package
pip install -r requirements.txt
```

Run the following command from the top folder:
```
pip install --editable .
```
You only need to run this command once. What it does is that it installs a package, called `senpy`, whose implementation is in the current folder (and not in the usual `site-packages`), so every subsequent code modifications while be taken into account.
You can directly go to the Usage section.



### Use cases : 


#### 1 - Use `notify-me` and `ntm` at the same time:

```python
from senpy import notify_me, ntm
from time import sleep

IDLE_TIME = 3 * 60 * 1000 ## 3 minutes

def very_long_computation():
    time.sleep(IDLE_TIME)
    
    
with ntm(range(0, 100)) as values:
    for value in values:
        if(value % 10 == 0):
            notify_me(f"We are at iteration {value}")


notify_me("The computation is done !")
```


#### 2 - Hyperparameter fine-tuning :

Here we try to find the appropriate value for the number of clusters. This computation can be time-consuming and cumbersome to track manually.

```python
from sklearn.cluster import KMeans
from senpy import notify_me, ntm


# random dataset generated by sklearn
X = make_blobs(n_samples=300_000, n_features=100)[0]

inertias = []

with ntm(range(1, 100, 10)) as nb_clusters:
    # as I use ntm, SenPy keeps me updated on job screen
    for i in nb_clusters:
        km = KMeans(n_clusters=i, init='random')
        km.fit(X)
        inertia.append(km.intertia_)


# at the end of the computation I get notified by SenPy
notify_me(f"KMeans fitted, inertia went from {inertias[0]} to , {inertias[-1]}")
```


#### 3 - Big model training :

The training of a convolutional neural network can be pretty cumbursome and long. SenPy helps you keep track of the training runtime and the evolution of the training error.

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torchvision import datasets, transforms
from torch.optim.lr_scheduler import StepLR

# We import the SenPy
from senpy import notify_me, ntm

class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, 3, 1)
        self.conv2 = nn.Conv2d(32, 64, 3, 1)
        self.dropout1 = nn.Dropout(0.25)
        self.dropout2 = nn.Dropout(0.5)
        self.fc1 = nn.Linear(9216, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = self.conv1(x)
        x = F.relu(x)
        x = self.conv2(x)
        x = F.relu(x)
        x = F.max_pool2d(x, 2)
        x = self.dropout1(x)
        x = torch.flatten(x, 1)
        x = self.fc1(x)
        x = F.relu(x)
        x = self.dropout2(x)
        x = self.fc2(x)
        output = F.log_softmax(x, dim=1)
        return output

def train(args, model, device, train_loader, optimizer, epoch):
    model.train()
    with ntm(enumerate(train_loader)) as stats :

        # with ntm, SenPy helps us keep track of the computation
        for batch_idx, (data, target) in stats :
            data, target = data.to(device), target.to(device)
            optimizer.zero_grad()
            output = model(data)
            loss = F.nll_loss(output, target)
            loss.backward()
            optimizer.step()
            if batch_idx % args.log_interval == 0:
                
                # we let SenPy notify us of the current training loss for this epoch
                notify_me('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(
                    epoch, batch_idx * len(data), len(train_loader.dataset),
                    100. * batch_idx / len(train_loader), loss.item()))
                if args.dry_run:
                    break
```


#### Brute-forcing passwords 

SenPy can, of course, be useful in applications that aren't Data Science. In fact it can be used for any long computation you can encounter in python. Here's an example in cryptography with brute force of a password using hashes.

```python
import requests
import hashlib
from urllib.request import urlopen

# importing senpy
from senpy import notify_me, ntm



# fetch the common passwords online
COMMON_PASSWORDS = str(requests.get("https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/probable-v2-top12000.txt").content).split('\\')

SEEKED_HASH = '5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8'


def hash(password):
    result = hashlib.sha1(password.encode())
    return result.hexdigest()

def bruteforce(common_password_list, actual_password_hash):
    with ntm(common_password_list) as common_passwords:
        # with ntm, SenPy let's you keep track of the amount of hashed studied
        for guess_password in common_passwords:
            if hash(guess_password) == actual_password_hash:
                return guess_password


if __name__ == '__main__':
    

    password = bruteforce(COMMON_PASSWORDS, SEEKED_HASH)

    # with notify_me, SenPy let's you know when the script is done and
    # if it returned a successful result
    notify_me(f"password found : {password}" if password is not None else "None of the common passwords matched")
```

